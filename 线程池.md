# Java 线程池

## 一、线程池核心概念

线程池是一个 **管理线程的容器**，可以复用线程、控制线程数量、管理任务队列，从而避免频繁创建和销毁线程带来的性能损耗。

### 1. 核心组成

| 概念                                 | 说明                                                                               |
|------------------------------------|----------------------------------------------------------------------------------|
| **核心线程（corePoolSize）**             | 线程池常驻线程数量，即使空闲也不会被销毁（除非设置允许超时）                                                   |
| **最大线程（maximumPoolSize）**          | 线程池允许创建的最大线程数                                                                    |
| **任务队列（workQueue）**                | 核心线程满时，任务存放在队列里等待执行                                                              |
| **线程空闲时间（keepAliveTime）**          | 超过核心线程的非核心线程空闲多久后销毁                                                              |
| **线程池状态**                          | RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED                                         |
| **拒绝策略（RejectedExecutionHandler）** | 当线程池和队列都满时，任务如何处理：AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy |

### 2. 线程池工作流程

1. 提交任务 →
2. 核心线程未满 → 创建核心线程执行
3. 核心线程满 → 放入队列
4. 队列满 → 创建非核心线程执行
5. 非核心线程满 → 执行拒绝策略

### 3. 线程池类型

| 类型                       | 特点                               | 适用场景            |
|--------------------------|----------------------------------|-----------------|
| **FixedThreadPool**      | 固定线程数，核心=最大，队列无界                 | CPU 密集型任务，任务量稳定 |
| **CachedThreadPool**     | 核心线程0，最大线程 Integer.MAX，线程空闲60s回收 | IO 密集型任务，任务量波动大 |
| **SingleThreadExecutor** | 单线程，保证任务顺序                       | 串行执行任务，如日志、顺序队列 |
| **ScheduledThreadPool**  | 支持定时/周期任务                        | 定时任务、轮询任务       |

---

## 二、线程池核心参数解释

| 参数                           | 作用           | 用途 / 注意事项                    |
|------------------------------|--------------|------------------------------|
| **corePoolSize**             | 核心线程数        | CPU密集型≈CPU核数+1，IO密集型≈CPU核数×2 |
| **maximumPoolSize**          | 最大线程数        | 任务高峰时允许额外创建线程，避免任务积压         |
| **queueCapacity**            | 任务队列容量       | 太小会扩展到最大线程数，太大可能任务堆积、响应慢     |
| **keepAliveSeconds**         | 非核心线程空闲存活时间  | IO密集型可适当加大，减少频繁创建销毁          |
| **allowCoreThreadTimeOut**   | 核心线程是否允许超时销毁 | 可减少空闲线程占用，适合任务量波动大的场景        |
| **threadNamePrefix**         | 线程名前缀        | 日志和监控定位线程来源                  |
| **rejectedExecutionHandler** | 拒绝策略         | 常用 CallerRunsPolicy 避免任务丢失   |

---
### Java 类配置示例
```java
@Configuration
public class ThreadPoolConfig {

    @Bean("fileTaskExecutor")
    public ThreadPoolTaskExecutor fileTaskExecutor() {
        // 创建线程池
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 获取CPU核数
        int cpuCores = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(cpuCores * 2);         // 设置核心线程数
        executor.setMaxPoolSize(cpuCores * 4);          // 设置最大线程数
        executor.setQueueCapacity(100);                 // 设置队列容量
        executor.setKeepAliveSeconds(60);               // 设置线程空闲时间
        executor.setThreadNamePrefix("file-io-task-");  // 设置线程名称前缀
        executor.setAwaitTerminationSeconds(120);       // 设置等待终止时间

        // ----------- 拒绝策略 -----------
        // 当线程池和队列都满时，任务由提交任务的线程执行
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        //初始化
        executor.initialize();
        return executor;
    }
}
```

## 三、线程池创建时机

- **线程池对象创建**：立即创建线程池实例
- **线程创建**：默认**不会马上创建核心线程**，只有提交任务时才会创建
- **预热核心线程**：

```java
executor.prestartAllCoreThreads(); // 立即创建所有核心线程
